(*
    Monadic contextual classification Mathematica package
    Copyright (C) 2017  Anton Antonov

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Written by Anton Antonov,
    antononcube @ gmail.com,
    Windermere, Florida, USA.
*)

(*
    Mathematica is (C) Copyright 1988-2017 Wolfram Research, Inc.

    Protected by copyright law and international treaties.

    Unauthorized reproduction or distribution subject to severe civil
    and criminal penalties.

    Mathematica is a registered trademark of Wolfram Research, Inc.
*)

(* :Title: MonadicContextualClassification *)
(* :Context: MonadicContextualClassification` *)
(* :Author: Anton Antonov *)
(* :Date: 2017-06-05 *)

(* :Package Version: 0.5 *)
(* :Mathematica Version: *)
(* :Copyright: (c) 2017 Anton Antonov *)
(* :Keywords: *)
(* :Discussion:


    ## Introduction

    This package provides functions for classification with classifiers with contexts.
    That is achieved by extending the functions of a State monad generated by the package
    "StateMonadCodeGenerator.m", [1], with functions specific to classification work flow.
    See [2] for explanations on monad code generation and extension.

    Here is an example of a pipeline created with the functions in the package:

       res =
         ClCon[ds, <||>] ⟹
           ClConSplitData[0.75] ⟹
           ClConMakeClassifier["NearestNeighbors"] ⟹
           ClConEchoFunctionContext[ClassifierInformation[#["classifier"]] &] ⟹
           ClConClassifierMeasurements[{"Accuracy", "Precision", "Recall"}] ⟹
           ClConEchoValue ⟹
           (If[#1["Accuracy"] > 0.7, None, ClCon[#1, #2]] &) ⟹
           ClConMakeClassifier["RandomForest"] ⟹
           ClConEchoFunctionContext[ClassifierInformation[#["classifier"]] &] ⟹
           ClConClassifierMeasurements[{"Accuracy", "Precision", "Recall"}] ⟹
           ClConEchoValue;


    ## Contexts

    The classifier contexts are Association objects. The pipeline values can have the form:

        ClCon[ val, context:(_String|_Association) ]

    see the explanations in [1] for more details.

    Some of the specific functions set or retrieve values from contexts for the keys:
    "trainData", "testData", "classifier".


    ## Error messages

    The error messages are print-outs with `Echo`. They can be easily changed to use `Message` instead.
    (`Echo` is used since it fits the monadic pipeline "culture.")


    ## Examples

    ### Data

    Assume we have the Titanic data as our working dataset:

       dataName = "Titanic";
       ds = Dataset[Flatten@*List @@@ ExampleData[{"MachineLearning", dataName}, "Data"]];
       varNames = Flatten[List @@ ExampleData[{"MachineLearning", dataName}, "VariableDescriptions"]];
       ds = ds[All, AssociationThread[varNames -> #] &];

    ### Complete usage example

    TBD...


    ### Complete usage example with string contexts

    TBD...


    ## References

    [1] Anton Antonov, StateMonadCodeGenerator.m, 2017, MathematicaForPrediction at GitHub.
        URL: https://github.com/antononcube/MathematicaForPrediction/blob/master/MonadicProgramming/StateMonadCodeGenerator.m

    [2] Anton Antonov, "Monad code generation and extension", 2017, MathematicaForPrediction at GitHub.
        URL: https://github.com/antononcube/MathematicaForPrediction/blob/master/MarkdownDocuments/Monad-code-generation-and-extension.md

    ## End matters

    This file was created by Mathematica Plugin for IntelliJ IDEA.

    Anton Antonov
    Windermere, FL, USA
    2017-06-05

*)

(*
    TODO:
     1. Add examples explained in detail.
     2. CANCELED Make a true package.
     3. DONE Add classifier ensemble handling.
     4. Give examples of tracking symbols.
*)

(*BeginPackage["MonadicContextualClassification`"]*)

(*ClConSplitData::usage = "ClConSplitData[fr_?NumberQ]";*)

(*ClConRecoverData::usage = "ClConRecoverData";*)

(*ClConMakeClassifier::usage = "ClConMakeClassifier[methodSpec_?MethodSpecQ]";*)

(*ClConClassifierMeasurements::usage = "ClConClassifierMeasurements[measures : (_String | {_String ..})]";*)

(*ClConAccuracyByVariableShuffling::usage = "ClConAccuracyByVariableShuffling[opts : OptionsPattern[]]";*)

(*Begin["`Private`"]*)

ClCon::gitimp = "Importing `1` from GitHub...";

If[Length[DownValues[MathematicaForPredictionUtilities`RecordsSummary]] == 0,
  Message[ClCon::gitimp, "MathematicaForPredictionUtilities.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/MathematicaForPredictionUtilities.m"]
];

If[Length[DownValues[OutlierIdentifiers`HampelIdentifierParameters]] == 0,
  Message[ClCon::gitimp, "OutlierIdentifiers.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/OutlierIdentifiers.m"]
];

If[Length[DownValues[StateMonadCodeGenerator`GenerateStateMonadCode]] == 0,
  Message[ClCon::gitimp, "StateMonadCodeGenerator.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/MonadicProgramming/StateMonadCodeGenerator.m"]
];

If[Length[DownValues[ClassifierEnsembles`EnsembleClassifierMeasurements]] == 0,
  Message[ClCon::gitimp, "ClassifierEnsembles.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/ClassifierEnsembles.m"]
];

If[Length[DownValues[VariableImportanceByClassifiers`AccuracyByVariableShuffling]] == 0,
  Message[ClCon::gitimp, "VariableImportanceByClassifiers.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/VariableImportanceByClassifiers.m"]
];

If[Length[DownValues[CrossTabulate`CrossTabulate]] == 0,
  Message[ClCon::gitimp, "CrossTabulate.m"];
  Import["https://raw.githubusercontent.com/antononcube/MathematicaForPrediction/master/CrossTabulate.m"]
];



(*Needs["StateMonadCodeGenerator`"]*)
(*Needs["VariableImportanceByClassifiers`"]*)

(* The definitions are made to have a prefix "ClCon" . *)

(**************************************************************)
(* Generation                                                 *)
(**************************************************************)

(* Generate base functions of ClCon monad (ClassifierWithContext) *)

GenerateStateMonadCode["ClCon","FailureSymbol" -> $ClConFailure]

(**************************************************************)
(* Infix operators                                            *)
(**************************************************************)

(* This should be already done by GenerateStateMonadCode. *)
(*DoubleLongRightArrow[x_?ClConUnitQ, f_] := ClConBind[x, f];*)

(**************************************************************)
(* General functions                                          *)
(**************************************************************)

ClearAll[ClConToNormalClassifierData]

Options[ClConToNormalClassifierData] = {"DeleteMissing"->True};

ClConToNormalClassifierData[td_Dataset,opts:OptionsPattern[]] :=
    If[ TrueQ[ OptionValue[ClConToNormalClassifierData,"DeleteMissing"]],
      Thread[#[[All, 1 ;; -2]] -> #[[All, -1]]] &@ Normal[DeleteMissing[td, 1, 2][All, Values]],
    (* ELSE *)
      Thread[#[[All, 1 ;; -2]] -> #[[All, -1]]] &@ Normal[td]
    ];


(**************************************************************)
(* Monad specific functions                                   *)
(**************************************************************)

Options[ClConSplitData] = {Method->"LabelsProportional"};

ClConSplitData[_][None] := None
ClConSplitData[fr_?NumberQ, opts:OptionsPattern[]][xs_, context_Association] :=
    Block[{method=OptionValue[ClConSplitData, Method], dataLabels, indGroups, t, trainData, testData},

      Which[
        method == "LabelsProportional",
        dataLabels =
            Transpose[{Range[Length[xs]], Normal[xs[[All, -1]]]}];
        indGroups = Map[#[[All, 1]] &, GroupBy[dataLabels, Last]];

        t = TakeDrop[RandomSample[#], Ceiling[fr*Length[#]]] & /@ indGroups;

        trainData = xs[[ Join @@ t[[All, 1]], All]];
        testData =  xs[[ Join @@ t[[All, 2]], All]],

        True,
        {trainData, testData} = TakeDrop[RandomSample[xs], Floor[fr*Length[xs]]];
      ];

      ClCon[AssociationThread[{"trainData", "testData"} -> {trainData, testData}], context]
    ] /; 0 < fr <= 1;


ClConRecoverData[None] := None;
ClConRecoverData[xs_, context_Association] :=
    Block[{},
      Which[
        MatchQ[xs, _Association] && KeyExistsQ[xs, "trainData"] && KeyExistsQ[xs, "testData"],
        ClCon[Join[xs["trainData"], xs["testData"]], context],

        KeyExistsQ[context, "trainData"] && KeyExistsQ[context, "testData"],
        ClCon[Join[context["trainData"], context["testData"]], context],

        True,
        Echo["Cannot recover data.","ClConRecoverData:"];
        $ClConFailure
      ]
    ];


ClConTakeData[None] := None;
ClConTakeData[xs_, context_] :=
    Fold[ ClConBind, ClConUnit[xs, context], {ClConRecoverData, ClConTakeValue}];


ClConTakeClassifier[None] := None;
ClConTakeClassifier[xs_, context_Association] := context["classifier"];


ClConTakeVariableNames[None] := None;
ClConTakeVariableNames[xs_, context_Association] :=
    Fold[ClConBind, ClConUnit[xs, context], {ClConGetVariableNames, ClConTakeValue}];


ClConGetVariableNames[None] := None;
ClConGetVariableNames[xs_, context_Association] :=
    Block[{},
      Which[
        TrueQ[Head[xs] === Dataset],
        ClCon[Normal[xs[1,Keys]], context],

        MatchQ[xs, _Association] && KeyExistsQ[xs, "trainData"] && TrueQ[Head[xs["trainData"]] == Dataset],
        ClCon[Normal[xs["trainData"][1,Keys]], context],

        KeyExistsQ[context, "trainData"] && KeyExistsQ[context, "testData"] && TrueQ[Head[context["trainData"]] == Dataset],
        ClCon[Normal[context["trainData"][1,Keys]], context],

        True,
        Echo["Cannot find the variable names: (1) the pipeline value is not a Dataset and (2) there is no \"trainData\" key in the context or the corresponding value is not a Dataset.",
             "ClConGetVariableNames:"];
        $ClConFailure
      ]
    ];


ClConEchoVariableNames[None] := None;
ClConEchoVariableNames[xs_, context_Association] :=
    Block[{t},
      t = Fold[ ClConBind, ClConUnit[xs,context], {ClConGetVariableNames, ClConTakeValue}];
      Echo[t,"variable names:"];
      ClConUnit[xs, context]
    ];


(************************************************************)
(* ClConMakeClassifier                                      *)
(************************************************************)

ClConMethodQ[x_] := StringQ[x]; (* And check is it known by Classify. *)

ClConMethodListQ[x_] := MatchQ[ x, {_?ClConMethodQ..} ];

ClConResamplingMethodQ[x_] := MatchQ[ x, (_Association | _String | {_String, _?NumberQ} | {_String, _?NumberQ, _Integer} | {_String, _?NumberQ, _Integer, RandomSample | RandomChoice}) ];

(* Note that is includes MethodListQ. *)
ClConResamplingMethodListQ[x_] := MatchQ[ x, { _?ClConResamplingMethodQ .. } ];

ClConMethodSpecQ[x_] := ClConMethodQ[x] || ClConResamplingMethodQ[x] || ClConResamplingMethodListQ[x];

ClConClassifierQ[ cl_ ] :=
    MatchQ[ cl, _ClassifierFunction] ||
        If[Length[DownValues[ClassifierEnsembles`EnsembleClassifierMeasurements]] > 0,
          MatchQ[ cl, Association[(_ -> _ClassifierFunction) ..] ]
        ];

ClConMakeClassifier[___][None] := None;

ClConMakeClassifier[][xs_, context_] := ClConMakeClassifier["LogisticRegression"][xs, context];

ClConMakeClassifier[methodSpec_?ClConMethodSpecQ][xs_, context_] :=
    Block[{cf, dataAssoc, newContext},

      Which[
        MatchQ[xs, _Association] && KeyExistsQ[xs, "trainData"] && KeyExistsQ[xs, "testData"],
        dataAssoc = xs; newContext = Join[context, xs],

        KeyExistsQ[context, "trainData"] && KeyExistsQ[context, "testData"],
        dataAssoc = context; newContext = <||>,

        True,
        Echo["Split the data first. (No changes in argument and context were made.)", "ClConMakeClassifier:"];
        Return[ClCon[xs, context]]
      ];

      Which[
        ClConMethodQ[methodSpec],
        cf = Classify[ClConToNormalClassifierData[dataAssoc@"trainData"], Method -> methodSpec],

        ClConMethodListQ[methodSpec],
        cf = EnsembleClassifier[ methodSpec, ClConToNormalClassifierData[dataAssoc@"trainData"] ],

        ClConResamplingMethodQ[methodSpec],
        cf = ResamplingEnsembleClassifier[ {methodSpec}, ClConToNormalClassifierData[dataAssoc@"trainData"] ],

        ClConResamplingMethodListQ[methodSpec],
        cf = ResamplingEnsembleClassifier[ methodSpec, ClConToNormalClassifierData[dataAssoc@"trainData"] ],

        True,
        Echo["Unknown classifier specification.", "ClConMakeClassifier:"];
        cf = None;
      ];

      If[ ! ClConClassifierQ[cf],
        Echo["Classifier making failure.", "ClConMakeClassifier:"];
        $ClConFailure,
      (* ELSE *)
        ClCon[cf, Join[context, newContext, <|"classifier" -> cf|>]]
      ]
    ];


(************************************************************)
(* ClConClassifierMeasurements                              *)
(************************************************************)

Options[ClConClassifierMeasurements] = { Method -> Automatic };

ClConClassifierMeasurements[___][None] := None;
ClConClassifierMeasurements[measures : (_String | {_String ..}), opts:OptionsPattern[]][xs_, context_] :=
    Block[{cm},
      Which[
        KeyExistsQ[context, "classifier"] && MatchQ[ context["classifier"], _ClassifierFunction],
        cm = ClassifierMeasurements[context["classifier"], ClConToNormalClassifierData[context@"testData"]];
        ClCon[AssociationThread[measures -> cm /@ Flatten[{measures}]], context],

        KeyExistsQ[context, "classifier"],
        cm = EnsembleClassifierMeasurements[ context["classifier"], ClConToNormalClassifierData[context@"testData"], Flatten[{measures}], opts];
        ClCon[AssociationThread[measures -> cm], context],

        True,
        Echo["Make a classifier first.", "ClConClassifierMeasurements:"];
        $ClConFailure
      ]
    ];


(************************************************************)
(* ClConAccuracyByVariableShuffling                         *)
(************************************************************)

Options[ClConAccuracyByVariableShuffling] = { "Classes" -> None };

ClConAccuracyByVariableShuffling[___][None] := None;

ClConAccuracyByVariableShuffling[][xs_, context_] :=
    ClConAccuracyByVariableShuffling["Classes" -> None][xs, context];

ClConAccuracyByVariableShuffling[opts : OptionsPattern[]][xs_, context_] :=
    Block[{fsClasses = FilterRules[{opts}, "Classes"]},

      If[Length[fsClasses] == 0 || fsClasses === Automatic, fsClasses = None];

      ClCon[
        AccuracyByVariableShuffling[
          context["classifier"],
          ClConToNormalClassifierData[context["testData"]],
          Most@Keys[Normal@context["testData"][[1]]],
          fsClasses],
        context]
    ];


(************************************************************)
(* ClConToLinearVectorSpaceRepresentation                   *)
(************************************************************)

ClConToLinearVectorSpaceRepresentation[data:(_?MatrixQ|_Dataset)] :=
    Block[{catData, smats, resMat, res},

      catData = ToCategoricalColumns[data];

      smats =
          Table[
            CrossTabulate[ Transpose[{Range[Length[catData]], Normal[catData[All, i]]}] ],
            {i, Length[data[1]]}];

      resMat = Transpose[Join @@ Map[Transpose[#["XTABMatrix"]] &, smats]];

      <| "XTABMatrix"->resMat, "RowNames"-> smats[[1]]["RowNames"], "ColumnNames" -> Join @@ Through[smats["ColumnNames"]] |>
    ];

ClConToLinearVectorSpaceRepresentation[][None] := None;

ClConToLinearVectorSpaceRepresentation[][xs_, context_] :=
    Block[{t},
      t = ClConBind[ ClConUnit[xs, context], ClConTakeData ];

      If[ t === $ClConFailure, Return[$ClConFailure] ];

      t = ClConToLinearVectorSpaceRepresentation[t];

      ClConUnit[t, context]
    ];


(************************************************************)
(* ClConOutlierPosition                                     *)
(************************************************************)

Options[ClConOutlierPosition] = {
  "CentralItemFunction" -> Mean,
  DistanceFunction -> EuclideanDistance,
  "OutlierIdentifierParameters" -> (TopOutliers@*SPLUSQuartileIdentifierParameters) };

ClConOutlierPosition[ data:(_?MatrixQ|_Dataset), opts:OptionsPattern[] ] :=
    Block[{avgFunc, distFunc, olParams, smat, avgItem, dists},

      avgFunc = OptionValue[ ClConOutlierPosition, "CentralItemFunction" ];
      distFunc = OptionValue[ ClConOutlierPosition, DistanceFunction ];
      olParams = OptionValue[ ClConOutlierPosition, "OutlierIdentifierParameters" ];

      Which[
        MatrixQ[data, NumberQ], smat = data,
        True, smat = ClConToLinearVectorSpaceRepresentation[data]["XTABMatrix"]
      ];

      avgItem = avgFunc[N@smat];

      dists = Map[distFunc[#, avgItem] &, Identity /@ smat];

      OutlierPosition[dists, olParams]
    ];

ClConOutlierPosition[___][None] := None;

ClConOutlierPosition[opts:OptionsPattern[]][xs_, context_] :=
    Block[{},

      Which[
        MatchQ[xs, _Association] && KeyExistsQ[xs, "trainData"] && KeyExistsQ[xs, "testData"],
        ClConUnit[<|"trainData"->ClConOutlierPosition[xs["trainData"],opts], "testData" -> ClConOutlierPosition[xs["testData"],opts] |>, context],

        KeyExistsQ[context, "trainData"] && KeyExistsQ[context, "testData"],
        ClConUnit[<|"trainData"->ClConOutlierPosition[context["trainData"],opts], "testData" -> ClConOutlierPosition[context["testData"],opts] |>, context],

        TrueQ[Head[xs] === Dataset],
        ClConUnit[ClConOutlierPosition[xs,opts], context],

        True,
        Echo["Cannot find data.","ClConOutlierPosition:"];
        $ClConFailure
      ]

    ];

(************************************************************)
(* ClConFindOutliersPerClass                                *)
(************************************************************)

Options[ClConFindOutliersPerClass] = {
  "OutlierIdentifierParameters" -> (TopOutliers@*SPLUSQuartileIdentifierParameters),
  "TrainingDataOnly" -> True,
  "ClassLabel" -> Automatic };

ClConFindOutliersPerClass[___][None] := None;

ClConFindOutliersPerClass[][xs_, context_Association] :=
    ClConFindOutliersPerClass["OutlierIdentifierParameters" -> (TopOutliers@*SPLUSQuartileIdentifierParameters) ][xs, context];

ClConFindOutliersPerClass[opts : OptionsPattern[]][xs_, context_Association] :=
    Block[{data, data2, aClassInds, outlierIdentifier, trainingDataOnlyQ, classLabel, classLabelInd, varNames, res},

      outlierIdentifier = OptionValue[ ClConFindOutliersPerClass, "OutlierIdentifierParameters"];
      trainingDataOnlyQ = OptionValue[ ClConFindOutliersPerClass, "TrainingDataOnly" ];
      classLabel = OptionValue[ ClConFindOutliersPerClass, "ClassLabel" ];

      If[ TrueQ[trainingDataOnlyQ],

        Which[

          AssociationQ[xs] && KeyExistsQ[xs, "trainData"],
          data = xs["trainData"],

          KeyExistsQ[context, "trainData"],
          data = context["trainData"],

          True,
          Echo["No training data.", "ClConFindOutliersPerClass::"];
          $ClConFailure

        ],

        (* ELSE *)
        data = ClConTakeData[xs, context]
      ];

      If[ TrueQ[Head[data] =!= Dataset],
        Print[data];
        Echo[ "The obtained data a Dataset object.", "ClConFindOutliersPerClass::"];
        Return[$ClConFailure]
      ];

      (* It is assumed below that data is a Dataset. *)

      varNames = ClConBind[ ClConUnit[xs,context], ClConTakeVariableNames ];

      Which[

        TrueQ[classLabel === Automatic],
        classLabel = varNames[[-1]];
        classLabelInd = Length[varNames],

        IntegerQ[classLabel],
        classLabelInd = classLabel;
        If[ !(1 <= classLabelInd <= Length[varNames]),
          Echo[ "The option \"ClassLabel\" value " <> classLabel <> " is not integer between 1 and " <> ToString[Length[varNames]] <>".", "ClConFindOutliersPerClass::"];
          Return[$ClConFailure]
        ];
        classLabel = varNames[[classLabelInd]],

        StringQ[classLabel],
        If[ !MemberQ[ varNames, classLabel ],
          Echo[ "The option \"ClassLabel\" value " <> classLabel <> " is not one of " <> ToString[varNames] <> ".", "ClConFindOutliersPerClass::"];
          Return[$ClConFailure]
        ];
        classLabelInd = First@Flatten@Position[varNames, classLabel],

        True,
        Return[$ClConFailure]

      ];

      data2 = data[ GroupBy[#[classLabel]&] ];

      res =
          AssociationThread[
            Normal[Keys[data2]],
            Table[ClConOutlierPosition[ds2[i], "OutlierIdentifierParameters" -> outlierIdentifier], {i, Length[data2]}]
          ];

      ClConUnit[res, context]
    ];

(*End[]  *`Private` *)

(*EndPackage[]*)
